Lab 1.5
1. To find the location of the following commands, the whereis command can be used. This commands prints the command file location for the file being specified. So, for sh, sleep, and export, I used the command “whereis sh sleep export” which will print the location of all three commands. The sh command is located in /usr/bin/sh. The sleep command is located in /usr/bin/sleep. For the export command, it did not contain a location so I used another command “type export” to tell me what the export command is. From this, I found that export is a shell built-in. 
2. First, to find all files in /usr/bin that are exactly two characters long and end with a ‘u’, I piped the ls command to grep which will search for the regular expression pattern I give it. The command is “ls /usr/bin | grep ^.u$”. This prints all matching patterns which give the result ‘du’ and ‘su’. To find out if these are executable commands and what they did, I used the commands “man du” and “man su”. Su is an executable command that allows users to execute commands as a substitute user and group ID. Du is an executable command that estimates file space usage. 
3. We can find out what file the symbolic link is referring to using the “ls -l” command which will print the metadata including where the link is pointing to. So, I ran the command “ls -l /usr/local/cs/bin/emacs” which showed that the file that is actually being executed is “emacs-27.2”.
4. To check the version number of the /usr/bin/gcc program, I used the command “/usr/bin/gcc --version”. For plain gcc, I used “gcc --version”. For /usr/bin/gcc, the version number is 8.5.0 and for plan gcc, the version number is 11.2.0. They are different programs because they do not refer to the same gcc. For /usr/bin/gcc, it follows an absolute path starting from the root directory and goes /usr/bin. On the other hand, the plain gcc points to another program. We can verify this by using the command “which gcc” that prints the path the plain gcc is pointing to. From this I get, “/usr/local/cs/bin/gcc” which clearly shows they refer to different programs. They are different programs because we are working in another path compared to /usr/bin/gcc since we prepended /usr/local/cs/bin to our path. So the plain gcc would refer to the latter one. 
5. To find the answer for this question, we can use the command “man chmod” which will give us a manual on the chmod command. In symbolic mode, we need to specify the who, the operator, and the permission. In this case, “u+sx” refers to the user (owner) and it is adding permission for them. The ‘s’ will set user ID on execution and the ‘x’ will add execution permission. On the other hand, “o-w” refers to others (those that are neither the owner or in the group) and is removing writing permission. 
6. First, I used the command “man find” to read about how to use find and the appropriate tests to run with the command to get the specific results. To perform the find command, I used “find /usr/local/cs -type d -mtime 28”. The test “-type” lets me specify find to look for directories and “-mtime” to specify the number of days which is 28 for 4 weeks. Running this command, no directories show up meaning none of them have been modified in the last 4 weeks. 
7. First, I used “whereis find” to print the same directory as the command find. This tells me that find is located in /usr/bin. Taking this information, I can run the command “find /usr/bin -maxdepth 1 -type l -printf l | wc -m” to print out the total number of symbolic links located in that directory. Maxdepth 1 tells us to only look inside that directory and not the subdirectories. Type l refers to symbolic links and printf l will print ‘l’ everytime it finds a symbolic link. Then piping this with the wc -m command, the number of symbolic links, which each occurrence shows up as a character ‘l’, will be printed. The answer I got is 319 symbolic links.
8. I first used “man ls” to look up options for ls that will simplify my search. Then I used the command “ls -alt /usr/lib64 | grep ‘^-’”. Here I am using the options -alt which will not exclude file names starting with ‘.’ and will print in a long format sorted by last modified date. The output will be piped to grep and will filter to look only for regular files. The oldest regular file here is ‘libbz2.so.1.0.6’.
9. To check what commands have transpose in their name, first go on emacs using command “emacs” and then use command “c-h a” which will allow the user to search for commands. Then, type “transpose” followed by RET to get a list of all commands with transpose in the name. The commands in emacs with transpose in their name are transpose-chars, transpose-lines, transpose-paragraphs, transpose-regions, transpose-sentences, transpose-sexps, and transpose-words.
10. Emacs yank is the equivalent of paste. It will paste from a queue called the kill ring that contains previous kills in order of most recent. To invoke a yank, you can use the keystroke “c-y” and if you want to yank previous kills from the kill ring you can use “M-y” to cycle through the yanks after doing the first “c-y”. 
11. In order to examine the difference between the two options, I used the command “ls -l /usr/bin” for the first part. And then in Emacs, I used “M-x dired” then typed the path “/usr/bin” to view the Emacs version. The difference in the output is that the “ls -l” version will print out the entire directory and place your shell window at the bottom of the list. On the other hand, when opening the directory with Emacs, it places you at the start of the list which you can then navigate to the bottom using commands such as “c-v” or “M->”. Furthermore, in Emacs dired, I am able to edit the directory whereas I cannot with “ls -l” which only prints the long list for the directory. 
12. Instead of using the ps command to show the login shell’s process and all the process’s ancestors and descendants, we can use the pstree command to make it simpler to understand the hierarchy. Using the command “pstree -p -s $$”, this will create a process tree that only outputs for this login shell’s process. From this, we get the login shell process which is bash and 4 ancestor processes which 3 are sshd and 1 is systemd. Then there is 1 descendant process which is the pstree process that was created when the command was ran.